var torrentStream = require('torrent-stream');
var http = require('http');
var fs = require('fs');
var rangeParser = require('range-parser');
var url = require('url');
var mime = require('mime');
var pump = require('pump');

var parseBlocklist = function(filename) {
	// TODO: support gzipped files
	var blocklistData = fs.readFileSync(filename, { encoding: 'utf8' });
	var blocklist = [];
	blocklistData.split('\n').forEach(function(line) {
		var match = null;
		if ((match = /^\s*[^#].*?\s*:\s*([a-f0-9.:]+?)\s*-\s*([a-f0-9.:]+?)\s*$/.exec(line))) {
			blocklist.push({
				start: match[1],
				end: match[2]
			});
		}
	});
	return blocklist;
};

var truthy = function() {
	return true;
};



var createServer = function(e, opts) {
	var server = http.createServer();
	var index = opts.index;
	var getType = opts.type || mime.lookup.bind(mime);
	var filter = opts.filter || truthy;
	var $ = opts.jquery;
	var _ = opts._;
	var dom = opts.dom;
	var ev = e;
	var options = opts;

	$(dom).off('click','.loadStreaming');
	$(dom).on('click','.loadStreaming',function(evt){
		evt.preventDefault();
		var i = $(this).attr('data-id');
		$.magnificPopup.close();
		$('#fbxMsg2').remove();
			$('#preloadTorrent').empty().remove();

			if (typeof index !== 'number') {
				index = e.files.reduce(function(a,b) {
					return a.name == i ? a : b;
				});
				index = e.files.indexOf(index);
			}
			e.files[index].select();
			server.index = e.files[index];

			if (opts.sort) e.files.sort(opts.sort);
	});

	$(dom).off('click','#closeMfp');
	$(dom).on('click','#closeMfp',function(evt){
		$.magnificPopup.close();
		$('#stopBtn').click();
		$('#homeToggle').click();
	});

	var onready = function() {
		setTimeout(function() {
			var html = '<div style="margin-top:50px;" class="panel panel-default"><div class="panel-heading"><h3 class="panel-title">'+_("Select the file to open...")+'</h3><a id="closeMfp" href="#" style="position:absolute;right:15px;top:60px;font-weight:bold;">X</a></div><div class="panel-body"><table class="table table-stripped table-hover table-bordered table-responsive"><thead><tr><th data-field="name" data-align="right" data-sortable="true">'+_("Name")+'</th><th data-field="size" data-align="left" data-sortable="true">'+_("Size")+'</th></tr></thead><tbody>';
			$('#preloadTorrent').empty().remove();
			$('#fbxMsg2').remove();
			if (e.files.length > 1) {
				$.each(e.files,function(i,file){
					html+='<tr><td><a href="#" class="loadStreaming" data-id="'+file.name+'">'+file.name+'</a></td><td> '+bytesToSize(file.length,2)+'</td></tr>';
					if(i+1 == e.files.length){
						$('#fbxMsg2').remove();
						html+='</tbody></table></div></div>';
						$.magnificPopup.open({
						  items: {
						    src: html
						  },
						  type: 'inline',prependTo : $('.mejs-container')
						  // You may add options here, they're exactly the same as for $.fn.magnificPopup call
						  // Note that some settings that rely on click event (like disableOn or midClick) will not work here
						}, 0);
					}
				})
			} else  {
				if (typeof index !== 'number') {
					index = e.files.reduce(function(a, b) {
						return a.length > b.length ? a : b;
					});
					index = e.files.indexOf(index);
				}

				ev.files[index].select();
				server.index = ev.files[index];

				if (opts.sort) ev.files.sort(opts.sort);
			}
		},1000);
	};


	if (e.torrent) onready();
	else e.on('ready', onready);

	server.on('request', function(request, response) {
		var u = url.parse(request.url);
		var host = request.headers.host || 'localhost';

		var toPlaylist = function() {
			var toEntry = function(file, i) {
				return '#EXTINF:-1,' + file.path + '\n' + 'http://' + host + '/' + i;
			};

			return '#EXTM3U\n' + e.files.filter(filter).map(toEntry).join('\n');
		};

		var toJSON = function() {
			var toEntry = function(file, i) {
				return {name:file.name, length:file.length, url:'http://'+host+'/'+i};
			};

			return JSON.stringify(e.files.filter(filter).map(toEntry), null, '  ');
		};

		// Allow CORS requests to specify arbitrary headers, e.g. 'Range',
		// by responding to the OPTIONS preflight request with the specified
		// origin and requested headers.
		response.setHeader("Content-Transfer-Encoding", "binary");
		response.setHeader('transferMode.dlna.org', 'Streaming');
		response.setHeader('contentFeatures.dlna.org','DLNA.ORG_OP=01;DLNA.ORG_CI=0;DLNA.ORG_FLAGS=017000 00000000000000000000000000');
		if (request.method === 'OPTIONS' && request.headers['access-control-request-headers']) {
			response.setHeader('Access-Control-Allow-Origin', request.headers.origin);
			response.setHeader('Access-Control-Allow-Methods', 'POST, GET, OPTIONS');
			response.setHeader(
					'Access-Control-Allow-Headers',
					request.headers['access-control-request-headers']);
			response.setHeader('Access-Control-Max-Age', '1728000');

			response.end();
			return;
		}

		if (request.headers.origin) response.setHeader('Access-Control-Allow-Origin', request.headers.origin);
		if (u.pathname === '/') u.pathname = '/'+index;

		if (u.pathname === '/favicon.ico') {
			response.statusCode = 404;
			response.end();
			return;
		}

		if (u.pathname === '/.json') {
			var json = toJSON();
			response.setHeader('Content-Type', 'application/json; charset=utf-8');
			response.setHeader('Content-Length', Buffer.byteLength(json));
			response.end(json);
			return;
		}

		if (u.pathname === '/.m3u') {
			var playlist = toPlaylist()
			response.setHeader('Content-Type', 'application/x-mpegurl; charset=utf-8');
			response.setHeader('Content-Length', Buffer.byteLength(playlist));
			response.end(playlist);
			return;
		}

		e.files.forEach(function(file, i) {
			if (u.pathname.slice(1) === file.name) u.pathname = '/'+i;
		});

		var i = Number(u.pathname.slice(1));

		if (isNaN(i) || i >= e.files.length) {
			response.statusCode = 404;
			response.end();
			return;
		}

		var file = e.files[i];
		var range = request.headers.range;
		range = range && rangeParser(file.length, range)[0];
		response.setHeader('Accept-Ranges', 'bytes');
		response.setHeader('Content-Type', 'video/mpeg');

		if (!range) {
			response.setHeader('Content-Length', file.length);
			if (request.method === 'HEAD') return response.end();
			pump(file.createReadStream(), response);
			return;
		}

		response.statusCode = 206;
		response.setHeader('Content-Length', range.end - range.start + 1);
		response.setHeader('Content-Range', 'bytes '+range.start+'-'+range.end+'/'+file.length);

		if (request.method === 'HEAD') return response.end();
		pump(file.createReadStream(range), response);
	});

	server.on('connection', function(socket) {
		socket.setTimeout(36000000);
	});

	return server;
};


function bytesToSize(bytes, precision)
{	
	var kilobyte = 1024;
	var megabyte = kilobyte * 1024;
	var gigabyte = megabyte * 1024;
	var terabyte = gigabyte * 1024;

	if ((bytes >= 0) && (bytes < kilobyte)) {
		return bytes + ' Bits';

	} else if ((bytes >= kilobyte) && (bytes < megabyte)) {
		return (bytes / kilobyte).toFixed(precision) + ' Ko';

	} else if ((bytes >= megabyte) && (bytes < gigabyte)) {
		return (bytes / megabyte).toFixed(precision) + ' Mo';

	} else if ((bytes >= gigabyte) && (bytes < terabyte)) {
		return (bytes / gigabyte).toFixed(precision) + ' Go';

	} else if (bytes >= terabyte) {
		return (bytes / terabyte).toFixed(precision) + ' To';
	} else {
		return bytes + 'Bits';
	}
}

module.exports = function(torrent, opts) {
	if (!opts) opts = {};

	// Parse blocklist
	if (opts.blocklist) opts.blocklist = parseBlocklist(opts.blocklist);

	var engine = torrentStream(torrent, opts);

	// Just want torrent-stream to list files.
	if (opts.list) return engine;

	// Pause/Resume downloading as needed
	engine.on('uninterested', function() { engine.swarm.pause();  });
	engine.on('interested',   function() { engine.swarm.resume(); });

	engine.server = createServer(engine, opts);

	// Listen when torrent-stream is ready, by default a random port.
	engine.on('ready', function() {
		engine.server.listen(opts.port || 0, opts.hostname);
	});

	if (opts.peerPort) engine.listen(opts.peerPort);

	return engine;
};
